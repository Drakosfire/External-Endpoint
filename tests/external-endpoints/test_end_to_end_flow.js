/**
 * End-to-End External Message Flow Test
 * Tests the complete SMS ‚Üí LibreChat ‚Üí AI ‚Üí Response flow
 */

const { connectDb } = require('./api/lib/db/connectDb');
const { findUser, createUser } = require('./api/models');
const { getConvo, saveConvo } = require('./api/models/Conversation');
const { v4: uuidv4 } = require('uuid');

// Test configuration
const BASE_URL = process.env.TEST_BASE_URL || 'http://localhost:3080';
const EXTERNAL_MESSAGE_API_KEY = process.env.EXTERNAL_MESSAGE_API_KEY || 'test-key';

/**
 * Simulate external SMS message payload
 */
function createSMSMessagePayload(phoneNumber, content, conversationId = null) {
    return {
        role: 'external',
        content: content,
        conversationId: conversationId || uuidv4(),
        metadata: {
            phoneNumber: phoneNumber,
            source: 'sms',
            createdBy: 'e2e-test',
            timestamp: new Date().toISOString()
        },
        from: phoneNumber
    };
}

/**
 * Test complete SMS user flow
 */
async function testCompleteUserFlow() {
    console.log('\nüë§ Testing Complete SMS User Flow...');

    const testPhoneNumber = '+1555E2E0001';
    const fetch = require('node-fetch');

    try {
        // Step 1: Send first SMS message (should create user and conversation)
        console.log('\nüì§ Step 1: Sending first SMS message...');
        const firstMessage = createSMSMessagePayload(
            testPhoneNumber,
            'Hello, this is my first message!'
        );

        const firstResponse = await fetch(`${BASE_URL}/api/messages/${firstMessage.conversationId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': EXTERNAL_MESSAGE_API_KEY
            },
            body: JSON.stringify(firstMessage)
        });

        console.log(`   Response Status: ${firstResponse.status}`);
        if (firstResponse.ok) {
            console.log('   ‚úÖ First message sent successfully');
        } else {
            const errorText = await firstResponse.text();
            console.log('   ‚ùå First message failed:', errorText);
            return { success: false, step: 'first_message', error: errorText };
        }

        // Step 2: Verify user was created
        console.log('\nüë§ Step 2: Verifying user creation...');
        const user = await findUser({
            $or: [
                { phoneNumber: testPhoneNumber },
                { 'metadata.phoneNumber': testPhoneNumber }
            ]
        });

        if (user) {
            console.log(`   ‚úÖ User created: ${user._id}`);
            console.log(`   üì± Phone: ${user.phoneNumber}`);
            console.log(`   üìß Email: ${user.email}`);
            console.log(`   üë§ Username: ${user.username}`);
        } else {
            console.log('   ‚ùå User not created');
            return { success: false, step: 'user_creation', error: 'User not found' };
        }

        // Step 3: Verify conversation was created
        console.log('\nüí¨ Step 3: Verifying conversation creation...');
        const conversation = await getConvo(user._id, firstMessage.conversationId);

        if (conversation) {
            console.log(`   ‚úÖ Conversation created: ${conversation.conversationId}`);
            console.log(`   üì± Phone in metadata: ${conversation.metadata?.phoneNumber}`);
            console.log(`   üîó User ID: ${conversation.user}`);
        } else {
            console.log('   ‚ùå Conversation not created');
            return { success: false, step: 'conversation_creation', error: 'Conversation not found' };
        }

        // Step 4: Send follow-up message (should use existing conversation)
        console.log('\nüì§ Step 4: Sending follow-up message...');
        const followUpMessage = createSMSMessagePayload(
            testPhoneNumber,
            'This is my second message in the same conversation.',
            firstMessage.conversationId // Use same conversation
        );

        const followUpResponse = await fetch(`${BASE_URL}/api/messages/${followUpMessage.conversationId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': EXTERNAL_MESSAGE_API_KEY
            },
            body: JSON.stringify(followUpMessage)
        });

        console.log(`   Response Status: ${followUpResponse.status}`);
        if (followUpResponse.ok) {
            console.log('   ‚úÖ Follow-up message sent successfully');
        } else {
            const errorText = await followUpResponse.text();
            console.log('   ‚ùå Follow-up message failed:', errorText);
            return { success: false, step: 'followup_message', error: errorText };
        }

        // Step 5: Test conversation discovery with placeholder ID
        console.log('\nüîç Step 5: Testing conversation discovery...');
        const placeholderMessage = createSMSMessagePayload(
            testPhoneNumber,
            'Testing conversation discovery with placeholder ID',
            'sms-conversation' // Placeholder that should find existing conversation
        );

        const placeholderResponse = await fetch(`${BASE_URL}/api/messages/sms-conversation`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': EXTERNAL_MESSAGE_API_KEY
            },
            body: JSON.stringify(placeholderMessage)
        });

        console.log(`   Response Status: ${placeholderResponse.status}`);
        if (placeholderResponse.ok) {
            console.log('   ‚úÖ Conversation discovery working correctly');
        } else {
            const errorText = await placeholderResponse.text();
            console.log('   ‚ö†Ô∏è Conversation discovery issue:', errorText);
            // This is not a critical failure for the overall flow
        }

        return {
            success: true,
            userId: user._id,
            conversationId: conversation.conversationId,
            phoneNumber: testPhoneNumber
        };

    } catch (error) {
        console.error('‚ùå Complete user flow test failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Test user isolation between different phone numbers
 */
async function testUserIsolation() {
    console.log('\nüîí Testing User Isolation Between Phone Numbers...');

    const phone1 = '+1555E2E0002';
    const phone2 = '+1555E2E0003';
    const fetch = require('node-fetch');

    try {
        // Send messages from two different phone numbers
        const message1 = createSMSMessagePayload(phone1, 'Message from phone 1');
        const message2 = createSMSMessagePayload(phone2, 'Message from phone 2');

        console.log('\nüì§ Sending messages from different phone numbers...');

        // Send first message
        const response1 = await fetch(`${BASE_URL}/api/messages/${message1.conversationId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': EXTERNAL_MESSAGE_API_KEY
            },
            body: JSON.stringify(message1)
        });

        // Send second message
        const response2 = await fetch(`${BASE_URL}/api/messages/${message2.conversationId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': EXTERNAL_MESSAGE_API_KEY
            },
            body: JSON.stringify(message2)
        });

        if (response1.ok && response2.ok) {
            console.log('   ‚úÖ Both messages sent successfully');
        } else {
            console.log('   ‚ùå One or both messages failed');
            return { success: false, error: 'Message sending failed' };
        }

        // Verify separate users were created
        console.log('\nüë• Verifying separate users were created...');

        const user1 = await findUser({ phoneNumber: phone1 });
        const user2 = await findUser({ phoneNumber: phone2 });

        if (user1 && user2) {
            console.log(`   ‚úÖ User 1: ${user1._id} (${phone1})`);
            console.log(`   ‚úÖ User 2: ${user2._id} (${phone2})`);

            if (user1._id.toString() !== user2._id.toString()) {
                console.log('   ‚úÖ Users are properly isolated');
                return {
                    success: true,
                    user1: user1._id,
                    user2: user2._id,
                    isolation: true
                };
            } else {
                console.log('   ‚ùå Users are not isolated (same ID)');
                return { success: false, error: 'User isolation failed' };
            }
        } else {
            console.log('   ‚ùå Users not created properly');
            return { success: false, error: 'User creation failed' };
        }

    } catch (error) {
        console.error('‚ùå User isolation test failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Test conversation persistence and metadata
 */
async function testConversationPersistence() {
    console.log('\nüíæ Testing Conversation Persistence & Metadata...');

    const testPhone = '+1555E2E0004';
    const fetch = require('node-fetch');

    try {
        // Send message with rich metadata
        const messageWithMetadata = createSMSMessagePayload(
            testPhone,
            'Testing metadata persistence'
        );

        // Add additional metadata
        messageWithMetadata.metadata.testField = 'test_value';
        messageWithMetadata.metadata.sessionId = uuidv4();
        messageWithMetadata.metadata.priority = 'high';

        console.log('\nüì§ Sending message with rich metadata...');

        const response = await fetch(`${BASE_URL}/api/messages/${messageWithMetadata.conversationId}`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': EXTERNAL_MESSAGE_API_KEY
            },
            body: JSON.stringify(messageWithMetadata)
        });

        if (!response.ok) {
            const errorText = await response.text();
            console.log('   ‚ùå Message with metadata failed:', errorText);
            return { success: false, error: errorText };
        }

        console.log('   ‚úÖ Message with metadata sent successfully');

        // Verify metadata persistence
        console.log('\nüîç Verifying metadata persistence...');

        // Wait a moment for processing
        await new Promise(resolve => setTimeout(resolve, 1000));

        const user = await findUser({ phoneNumber: testPhone });
        if (!user) {
            console.log('   ‚ùå User not found for metadata verification');
            return { success: false, error: 'User not found' };
        }

        const conversation = await getConvo(user._id, messageWithMetadata.conversationId);
        if (!conversation) {
            console.log('   ‚ùå Conversation not found for metadata verification');
            return { success: false, error: 'Conversation not found' };
        }

        console.log('   üìä Conversation metadata:');
        console.log(`      Phone: ${conversation.metadata?.phoneNumber}`);
        console.log(`      Source: ${conversation.metadata?.source}`);
        console.log(`      Created by: ${conversation.metadata?.createdBy}`);
        console.log(`      Test field: ${conversation.metadata?.testField}`);

        // Verify critical metadata
        const metadataValid = conversation.metadata?.phoneNumber === testPhone &&
            conversation.metadata?.source === 'sms' &&
            conversation.metadata?.createdBy === 'e2e-test';

        if (metadataValid) {
            console.log('   ‚úÖ Metadata preserved correctly');
            return {
                success: true,
                conversationId: conversation.conversationId,
                metadata: conversation.metadata
            };
        } else {
            console.log('   ‚ùå Metadata not preserved correctly');
            return { success: false, error: 'Metadata validation failed' };
        }

    } catch (error) {
        console.error('‚ùå Conversation persistence test failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Test error handling and edge cases
 */
async function testErrorHandling() {
    console.log('\nüõ°Ô∏è Testing Error Handling & Edge Cases...');

    const fetch = require('node-fetch');

    try {
        const tests = [
            {
                name: 'Invalid phone number',
                payload: {
                    role: 'external',
                    content: 'Test with invalid phone',
                    metadata: { phoneNumber: 'invalid-phone' }
                },
                expectedStatus: 400
            },
            {
                name: 'Missing phone number',
                payload: {
                    role: 'external',
                    content: 'Test with no phone',
                    metadata: { source: 'sms' }
                },
                expectedStatus: 400
            },
            {
                name: 'Invalid API key',
                payload: createSMSMessagePayload('+1555TEST999', 'Test invalid API key'),
                headers: { 'x-api-key': 'invalid-key' },
                expectedStatus: 403
            },
            {
                name: 'Missing API key',
                payload: createSMSMessagePayload('+1555TEST998', 'Test missing API key'),
                headers: {}, // No API key
                expectedStatus: 401
            }
        ];

        let passedTests = 0;

        for (const test of tests) {
            console.log(`\nüìã Testing: ${test.name}`);

            const headers = {
                'Content-Type': 'application/json',
                'x-api-key': EXTERNAL_MESSAGE_API_KEY,
                ...test.headers
            };

            const response = await fetch(`${BASE_URL}/api/messages/${uuidv4()}`, {
                method: 'POST',
                headers: headers,
                body: JSON.stringify(test.payload)
            });

            if (response.status === test.expectedStatus) {
                console.log(`   ‚úÖ ${test.name}: Status ${response.status} (expected)`);
                passedTests++;
            } else {
                console.log(`   ‚ùå ${test.name}: Status ${response.status} (expected ${test.expectedStatus})`);
            }
        }

        console.log(`\nüìä Error handling tests: ${passedTests}/${tests.length} passed`);

        return {
            success: passedTests === tests.length,
            passed: passedTests,
            total: tests.length
        };

    } catch (error) {
        console.error('‚ùå Error handling test failed:', error);
        return { success: false, error: error.message };
    }
}

/**
 * Clean up test data
 */
async function cleanupE2ETestData() {
    console.log('\nüßπ Cleaning up E2E test data...');

    try {
        // Remove test users
        const User = require('./api/models/User');
        const deletedUsers = await User.deleteMany({
            $or: [
                { phoneNumber: /\+1555E2E/ },
                { email: /e2e-test/ }
            ]
        });
        console.log(`‚úÖ Removed ${deletedUsers.deletedCount} test users`);

        // Remove test conversations
        const { Conversation } = require('./api/models/Conversation');
        const deletedConversations = await Conversation.deleteMany({
            'metadata.createdBy': 'e2e-test'
        });
        console.log(`‚úÖ Removed ${deletedConversations.deletedCount} test conversations`);

        // Remove test messages
        const Message = require('./api/models/Message');
        const deletedMessages = await Message.deleteMany({
            'metadata.createdBy': 'e2e-test'
        });
        console.log(`‚úÖ Removed ${deletedMessages.deletedCount} test messages`);

    } catch (error) {
        console.warn('‚ö†Ô∏è E2E cleanup error (non-critical):', error.message);
    }
}

/**
 * Run all end-to-end tests
 */
async function runAllE2ETests() {
    console.log('üöÄ Starting End-to-End External Message Flow Tests\n');
    console.log('='.repeat(70));

    try {
        // Connect to database
        await connectDb();
        console.log('‚úÖ Connected to MongoDB for E2E testing');

        let testResults = {
            completeUserFlow: { success: false },
            userIsolation: { success: false },
            conversationPersistence: { success: false },
            errorHandling: { success: false }
        };

        // Test 1: Complete User Flow
        console.log('\nüìã Test 1: Complete SMS User Flow');
        try {
            testResults.completeUserFlow = await testCompleteUserFlow();
            console.log(testResults.completeUserFlow.success ? '‚úÖ Complete User Flow: PASSED' : '‚ùå Complete User Flow: FAILED');
        } catch (error) {
            console.log('‚ùå Complete User Flow: FAILED -', error.message);
        }

        // Test 2: User Isolation
        console.log('\nüìã Test 2: User Isolation');
        try {
            testResults.userIsolation = await testUserIsolation();
            console.log(testResults.userIsolation.success ? '‚úÖ User Isolation: PASSED' : '‚ùå User Isolation: FAILED');
        } catch (error) {
            console.log('‚ùå User Isolation: FAILED -', error.message);
        }

        // Test 3: Conversation Persistence
        console.log('\nüìã Test 3: Conversation Persistence');
        try {
            testResults.conversationPersistence = await testConversationPersistence();
            console.log(testResults.conversationPersistence.success ? '‚úÖ Conversation Persistence: PASSED' : '‚ùå Conversation Persistence: FAILED');
        } catch (error) {
            console.log('‚ùå Conversation Persistence: FAILED -', error.message);
        }

        // Test 4: Error Handling
        console.log('\nüìã Test 4: Error Handling');
        try {
            testResults.errorHandling = await testErrorHandling();
            console.log(testResults.errorHandling.success ? '‚úÖ Error Handling: PASSED' : '‚ùå Error Handling: FAILED');
        } catch (error) {
            console.log('‚ùå Error Handling: FAILED -', error.message);
        }

        // Summary
        console.log('\n' + '='.repeat(70));
        console.log('üìä END-TO-END TEST RESULTS SUMMARY');
        console.log('='.repeat(70));

        const passedTests = Object.values(testResults).filter(result => result.success).length;
        const totalTests = Object.keys(testResults).length;

        console.log(`üéØ Overall: ${passedTests}/${totalTests} test suites passed`);
        console.log(`‚úÖ Complete User Flow: ${testResults.completeUserFlow.success ? 'PASS' : 'FAIL'}`);
        console.log(`‚úÖ User Isolation: ${testResults.userIsolation.success ? 'PASS' : 'FAIL'}`);
        console.log(`‚úÖ Conversation Persistence: ${testResults.conversationPersistence.success ? 'PASS' : 'FAIL'}`);
        console.log(`‚úÖ Error Handling: ${testResults.errorHandling.success ? 'PASS' : 'FAIL'}`);

        if (testResults.errorHandling.success) {
            console.log(`   Error Handling Details: ${testResults.errorHandling.passed}/${testResults.errorHandling.total} tests passed`);
        }

        if (passedTests === totalTests) {
            console.log('\nüéâ All end-to-end tests passed! External message system is working correctly.');
            console.log('üí¨ SMS ‚Üí LibreChat ‚Üí AI ‚Üí Response flow is fully operational.');
        } else {
            console.log('\n‚ö†Ô∏è Some end-to-end tests failed. External message system needs attention.');
            console.log('üîß Check the failed tests above for specific issues to address.');
        }

        return testResults;

    } catch (error) {
        console.error('‚ùå E2E test suite failed:', error);
        return false;
    } finally {
        await cleanupE2ETestData();
        process.exit(0);
    }
}

// Export for use in other test files
module.exports = {
    createSMSMessagePayload,
    testCompleteUserFlow,
    testUserIsolation,
    testConversationPersistence,
    testErrorHandling,
    runAllE2ETests
};

// Run if called directly
if (require.main === module) {
    runAllE2ETests().catch(console.error);
} 